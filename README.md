# woowahan-hexagonal
=======
# 우아한 객체지향 예제 헥사고날 적용

- 패키지 구성은 기능에 집중할 수 있도록 기능(Feature) 우선적으로 패키징한다.
- 기능별 패키지 하위는 패키징하지 않거나 클래스 역할별로 패키징한다.
    - port.in/out
        - 인 바운드 포트는 내부 영역 사용을 위해 표출된 API로 외부 영역의 인 바운드 어댑터가 호출
        - 아웃 바운드 포트는 내부 영역이 외부를 호출하는 방법을 정의한다.
    - adapter in/out
        - 인 바운드 어댑터는 외부에서 들어오는 요청을 처리한다.
        - 아웃 바운드 어댑터는 비즈니스 로직에 의해 호출되어 외부와 연계된다.
            - 아웃 바운드 포트의 구현체
- controller와 service 사이에 facade 계층을 만들어 각 레이어별 응집도를 높힌다.
    - 컨트롤러는 사용자의 요청을 해석하고 검증하는 역할/ 파사드는 도메인 영역과 컨트롤러 영역을 연결하는 중간다리/ 서비스는 도메인 객체를 통해 사용자의 요청을 처리하는 영역
    - 트랜잭션 분리는 파사드에서 처리
        - ex) 트랜잭션 처리 후 이벤트 발행

## **기능 패키지 구성**

- billing,delivery,order,shop,generic
    - 기능별 패키지는 서로 사이클이 돌지 않도록 구성
    - 기능 패키지 구성은 조영호님 강의 참고

|기능 하위 패키지|설명|비고|
|------|---|---|
|adapter|web/listenr 등 외부 요청을 받는 어댑터/ 외부와 연계되는 아웃 바운드 포트의 구현체|adapter.in/adapter.out|
|service|Service 클래스의 구현체와 외부에서 호출할 수 있는 in포트/ 비즈니스 로직에서 외부 의존성을 호출할 수 있는 out 포트|service.port.in/service.port.out|
|domain|Entity, ValueObject||

### 고민되는 점

- 에그리거터간 의존관계가 필요할 때 어떻게 처리할까?
    - 타 에그리거터의 port.out을 이용해 호출한다.
    - 패키지 사이클이 돌지 않도록 한다.
- 에그리거터간 공유되는 이벤트 메시지 스펙은 어떻게 할 것 인가?
    - 외부 공유 스펙으로 adapter in/port out에 구성한다.
- 경계간 매핑 전략은 필요할때만 사용한다.
    - jpa사용시 도메인과 jpa entity를 분리하면 중복 코드가 너무 많음
    - 필요한 경우에만 분리하는게 좋아보임
    - 레이어간 dto도 필요한 경우에만 매핑한다.
